'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');

/**
 * Hook to automatically request focus for an DOM element.
 *
 * @param isFocused if true, the focus will be requested
 * @param options options of the focus request
 * @return the ref which holds the element
 */
var useAutoFocus = function useAutoFocus() {
  var isFocused = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var options = arguments.length > 1 ? arguments[1] : undefined;
  var elementRef = react.useRef();
  react.useEffect(function () {
    if (isFocused && elementRef.current) {
      elementRef.current.focus(options);
    }
  }, [elementRef, isFocused]);
  return elementRef;
};

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var debounce = function debounce(fn, delay) {
  if (delay === undefined || delay === null) {
    return fn;
  }

  var timer;
  var callback;

  function f() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var context = this;
    clearTimeout(timer);

    callback = function callback() {
      return fn.apply(context, args);
    };

    timer = setTimeout(callback, delay);
    return context;
  }

  f.flush = function () {
    clearTimeout(timer);
    callback();
  };

  f.cancel = function () {
    return clearTimeout(timer);
  };

  return f;
};
var isRunningOnBrowser = typeof window !== 'undefined' && window.document;

/**
 * Hook to memoize a debounced version of a callback.
 *
 * @param callback the callback to debounce
 * @param delay the number of milliseconds to delay
 * @param deps the hook dependencies
 * @return a memoized and debounced callback
 */

var useDebouncedCallback = function useDebouncedCallback(callback, delay, deps) {
  return react.useMemo(function () {
    return debounce(callback, delay);
  }, Array.isArray(deps) ? [delay].concat(_toConsumableArray(deps)) : undefined);
};

/**
 * Hook to debounce the state updater function returned by hooks like `useState()` and `useReducer()`.
 *
 * @param pair - the state and updater pair which will be debounced
 * @param pair.0 - the state value
 * @param pair.1 - the state updater function
 * @param delay - the number of milliseconds to delay the updater
 * @return a state value and debounced updater pair
 */

var useDebouncedUpdates = function useDebouncedUpdates(_ref, delay) {
  var _ref2 = _slicedToArray(_ref, 2),
      value = _ref2[0],
      update = _ref2[1];

  return [value, useDebouncedCallback(update, delay, [])];
};
/**
 * Hook to create a reduced state with a debounced `dispatch()` function.
 *
 * @param reducer - the reducer function
 * @param initializerArg - the initial state value or the argument passed to the initial state generator function
 * @param initializer - the initial state generator function
 * @param delay - the number of milliseconds to delay the updater
 * @return a state and debounced `dispatch()` function
 */

var useDebouncedReducer = function useDebouncedReducer(reducer, initializerArg, initializer, delay) {
  return useDebouncedUpdates(react.useReducer(reducer, initializerArg, initializer), delay);
};
/**
 * Hook to create a state with a debounced setter function.
 *
 * @param initialValue - the initial state value or the initial state generator function
 * @param delay - the number of milliseconds to delay the updater
 * @return a state and debounced setter function
 */

var useDebouncedState = function useDebouncedState(initialValue, delay) {
  return useDebouncedUpdates(react.useState(initialValue), delay);
};

/**
 * Hook to keep a debounced reference of a value.
 *
 * @param value the value to be debounced
 * @param delay the number of milliseconds to delay
 * @return a debounced value
 */

var useDebouncedValue = function useDebouncedValue(value, delay) {
  var _useState = react.useState(value),
      _useState2 = _slicedToArray(_useState, 2),
      debouncedValue = _useState2[0],
      setDebouncedValue = _useState2[1];

  react.useEffect(function () {
    var timer = setTimeout(function () {
      setDebouncedValue(value);
    }, delay);
    return function () {
      clearTimeout(timer);
    };
  }, [value, delay]);
  return debouncedValue;
};

/**
 * Hook equivalent to useRef, but with a lazy initialization for computed value.
 *
 * @param initializer the function the computes the ref value
 * @return the ref
 */

var useLazyRef = function useLazyRef(initializer) {
  return react.useState(function () {
    var ref = react.createRef();
    ref.current = initializer();
    return ref;
  })[0];
};

/**
 * Hook to listen to a media query.
 *
 * @param [query] - the CSS3 media query expression
 * @return `true` if the media query matches; `false` is it does not match or the query is not defined
 */

var useMediaQuery = function useMediaQuery(query) {
  var _useState = react.useState(function () {
    if (!query || !isRunningOnBrowser) {
      return false;
    }

    var _window$matchMedia = window.matchMedia(query),
        matches = _window$matchMedia.matches;

    return !!matches;
  }),
      _useState2 = _slicedToArray(_useState, 2),
      matches = _useState2[0],
      setMatches = _useState2[1];

  react.useEffect(function () {
    if (!query || !isRunningOnBrowser) {
      return;
    }

    var mediaQueryListener = window.matchMedia(query);
    setMatches(mediaQueryListener.matches);

    var handleChange = function handleChange() {
      setMatches(!!mediaQueryListener.matches);
    };

    mediaQueryListener.addListener(handleChange);
    return function () {
      mediaQueryListener.removeListener(handleChange);
    };
  }, [query]);
  return matches;
};

/**
 * Hook to merge refs and callbacks refs into a single callback ref. Useful when your component need a internal ref
 * while receiving a forwared ref.
 *
 * @param refs - the refs and callback refs that should be merged
 * @return a merged callback ref
 */
var useMergedRefs = function useMergedRefs() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }

  return react.useCallback(function (refValue) {
    refs.filter(Boolean).forEach(function (ref) {
      if (typeof ref === 'function') {
        ref(refValue);
        return;
      }

      if (_typeof(ref) === 'object') {
        ref.current = refValue;
      }
    });
  }, refs);
};

/**
 * Hook to create a stable callback from a mutable one.
 *
 * @param fn the mutable callback
 * @return a stable callback
 */

var useMutableCallback = function useMutableCallback(fn) {
  var fnRef = react.useRef(fn);
  fnRef.current = fn;
  return react.useCallback(function () {
    return fnRef.current && (fnRef.current).apply(void 0, arguments);
  }, []);
};

/**
 * Hook to track dimension changes in a DOM element using the ResizeObserver API.
 *
 * @param options
 * @param options.debounceDelay the number of milliseconds to delay updates
 * @return a triple containing the ref and the size information
 */
var useResizeObserver = function useResizeObserver() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      debounceDelay = _ref.debounceDelay;

  var ref = react.useRef();

  var _useDebouncedState = useDebouncedState({}, debounceDelay),
      _useDebouncedState2 = _slicedToArray(_useDebouncedState, 2),
      _useDebouncedState2$ = _useDebouncedState2[0],
      contentBoxSize = _useDebouncedState2$.contentBoxSize,
      borderBoxSize = _useDebouncedState2$.borderBoxSize,
      setSizes = _useDebouncedState2[1];

  react.useEffect(function () {
    var observer = new ResizeObserver(function (_ref2) {
      var _ref3 = _slicedToArray(_ref2, 1),
          entry = _ref3[0];

      var contentBoxSize = entry.contentBoxSize,
          borderBoxSize = entry.borderBoxSize;

      if (contentBoxSize && borderBoxSize) {
        setSizes({
          contentBoxSize: contentBoxSize,
          borderBoxSize: borderBoxSize
        });
        return;
      }

      var target = entry.target,
          contentRect = entry.contentRect;
      var contentBoxInlineSize = contentRect.width,
          contentBoxBlockSize = contentRect.height;

      var _target$getBoundingCl = target.getBoundingClientRect(),
          borderBoxInlineSize = _target$getBoundingCl.width,
          borderBoxBlockSize = _target$getBoundingCl.height;

      setSizes({
        contentBoxSize: {
          inlineSize: contentBoxInlineSize,
          blockSize: contentBoxBlockSize
        },
        borderBoxSize: {
          inlineSize: borderBoxInlineSize,
          blockSize: borderBoxBlockSize
        }
      });
    });

    if (ref.current) {
      observer.observe(ref.current);
    }

    return function () {
      observer.disconnect();
    };
  }, []);
  return {
    ref: ref,
    contentBoxSize: contentBoxSize,
    borderBoxSize: borderBoxSize
  };
};

/**
 * Hook that wraps pairs of state and updater to provide a new updater which
 * can be safe and asynchronically called even after the component unmounted.
 *
 * @param pair - the state and updater pair which will be patched
 * @param pair.0 - the state value
 * @param pair.1 - the state updater function
 * @return a state value and safe updater pair
 */

var useSafely = function useSafely(_ref) {
  var _ref2 = _slicedToArray(_ref, 2),
      state = _ref2[0],
      updater = _ref2[1];

  var mountedRef = react.useRef(true);
  react.useEffect(function () {
    mountedRef.current = true;
    return function () {
      mountedRef.current = false;
    };
  });
  var safeUpdater = useMutableCallback(function () {
    if (!mountedRef.current) {
      return;
    }

    updater.apply(void 0, arguments);
  });
  return [state, safeUpdater];
};

/**
 * Hook to create a toggleable boolean state.
 *
 * @param initialValue - the initial value or the initial state generator function
 * @return a state boolean value and a state toggler function
 */

var useToggle = function useToggle(initialValue) {
  var _useState = react.useState(function () {
    return typeof initialValue === 'function' ? !!initialValue() : !!initialValue;
  }),
      _useState2 = _slicedToArray(_useState, 2),
      value = _useState2[0],
      setValue = _useState2[1];

  return [value, function (forcedValue) {
    return setValue(typeof forcedValue !== 'undefined' ? forcedValue : !value);
  }];
};

var useUniqueId = function useUniqueId() {
  return react.useMemo(function () {
    return Math.random().toString(36).slice(2);
  }, []);
};

exports.useAutoFocus = useAutoFocus;
exports.useDebouncedCallback = useDebouncedCallback;
exports.useDebouncedReducer = useDebouncedReducer;
exports.useDebouncedState = useDebouncedState;
exports.useDebouncedUpdates = useDebouncedUpdates;
exports.useDebouncedValue = useDebouncedValue;
exports.useLazyRef = useLazyRef;
exports.useMediaQuery = useMediaQuery;
exports.useMergedRefs = useMergedRefs;
exports.useMutableCallback = useMutableCallback;
exports.useResizeObserver = useResizeObserver;
exports.useSafely = useSafely;
exports.useToggle = useToggle;
exports.useUniqueId = useUniqueId;
//# sourceMappingURL=index.js.map
